//go:build e2e

/*
Copyright Edgeless Systems GmbH

SPDX-License-Identifier: Apache-2.0
*/

// Tests that the hashes generated by this library match the ones from a given file.
// The file should be generated by the upstream tool (https://github.com/IBM/sev-snp-measure).
// Run with: go test --tags=e2e --expected-values data.json --ovmf ovmf_img.fd
package e2e

import (
	"bytes"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strconv"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/virtee/sev-snp-measure-go/guest"
	"github.com/virtee/sev-snp-measure-go/ovmf"
	"github.com/virtee/sev-snp-measure-go/vmmtypes"
)

var (
	valuesPath = flag.String("expected-values", "", "Path to json file containing hashes to compare against.")
	binaryPath = flag.String("ovmf", "", "Path to OVMF binary that should be measured.")
)

func TestCompatibility(t *testing.T) {
	assert := assert.New(t)
	require := require.New(t)

	require.NotEmpty(*valuesPath, "expected-values flag must be set")
	require.NotEmpty(*binaryPath, "ovmf flag must be set")

	values, err := os.ReadFile(*valuesPath)
	require.NoError(err, "reading values file: %s", err)

	var expectedValues []expectedValues
	err = json.Unmarshal(values, &expectedValues)
	require.NoError(err, "unmarshalling values file: %s", err)

	ovmfObj, err := ovmf.New(*binaryPath, 0)
	require.NoError(err, "creating OVMF object from: %s", err)

	for _, entry := range expectedValues {
		ovmfHash, err := guest.OVMFHash(ovmfObj)
		require.NoError(err, "calculating OVMF hash: %s", err)

		// Documentation for guestFeatures value: https://github.com/virtee/sev-snp-measure/pull/32/files#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5R126.
		digest, err := guest.LaunchDigestFromOVMF(ovmfObj, 0x21, entry.vcpus, ovmfHash, vmmtypes.EC2, "")
		require.NoError(err, "calculating launch digest: %s", err)

		assert.True(bytes.Equal(digest, entry.measurement), "expected hash %x, got %x", entry.measurement, digest)
	}
}

type expectedValues struct {
	vcpus       int
	measurement []byte
}

func (e *expectedValues) UnmarshalJSON(data []byte) error {
	var tmp map[string]any
	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}
	vcpus, err := strconv.ParseInt(tmp["vcpus"].(string), 10, 64)
	if err != nil {
		return fmt.Errorf("parsing vcpus: %w", err)
	}
	measurement, err := hex.DecodeString(tmp["measurement"].(string))
	if err != nil {
		return fmt.Errorf("decoding measurement: %w", err)
	}
	e.vcpus = int(vcpus)
	e.measurement = measurement
	return nil
}
